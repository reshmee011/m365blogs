<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Clojure Sequences | m365 blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Sequences include data structure lists, vectors and lazy sequences. Functions that can be used with sequences can be found using the clojure cheatsheet. http://clojure.org/cheatsheet Below are some examples using vectors and lists as sequences.
Syntax
Definition
Result
(seq &lsquo;(1 2 3 4))
If collection is not empty, return seq object else nil
(1 2 3 4)
(first [1 2 3 4])
returns the first element
1
(rest {:a 1 :b 2 :c 3 :d 4})">
    <meta name="generator" content="Hugo 0.111.3">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
      <link href="/clojure-sequences/index.xml" rel="alternate" type="application/rss+xml" title="m365 blog" />
      <link href="/clojure-sequences/index.xml" rel="feed" type="application/rss+xml" title="m365 blog" />
      
    
    
    <meta property="og:title" content="Clojure Sequences" />
<meta property="og:description" content="Sequences include data structure lists, vectors and lazy sequences. Functions that can be used with sequences can be found using the clojure cheatsheet. http://clojure.org/cheatsheet Below are some examples using vectors and lists as sequences.
Syntax
Definition
Result
(seq &lsquo;(1 2 3 4))
If collection is not empty, return seq object else nil
(1 2 3 4)
(first [1 2 3 4])
returns the first element
1
(rest {:a 1 :b 2 :c 3 :d 4})" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://famous-cajeta-4dad83.netlify.app/clojure-sequences/" /><meta property="article:section" content="" />
<meta property="article:published_time" content="2015-12-10T09:32:23+00:00" />
<meta property="article:modified_time" content="2015-12-10T09:32:23+00:00" />
<meta itemprop="name" content="Clojure Sequences">
<meta itemprop="description" content="Sequences include data structure lists, vectors and lazy sequences. Functions that can be used with sequences can be found using the clojure cheatsheet. http://clojure.org/cheatsheet Below are some examples using vectors and lists as sequences.
Syntax
Definition
Result
(seq &lsquo;(1 2 3 4))
If collection is not empty, return seq object else nil
(1 2 3 4)
(first [1 2 3 4])
returns the first element
1
(rest {:a 1 :b 2 :c 3 :d 4})"><meta itemprop="datePublished" content="2015-12-10T09:32:23+00:00" />
<meta itemprop="dateModified" content="2015-12-10T09:32:23+00:00" />
<meta itemprop="wordCount" content="1002">
<meta itemprop="keywords" content="Clojure,Clojure Sequences,Coljure Sequences,Uncategorized," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Clojure Sequences"/>
<meta name="twitter:description" content="Sequences include data structure lists, vectors and lazy sequences. Functions that can be used with sequences can be found using the clojure cheatsheet. http://clojure.org/cheatsheet Below are some examples using vectors and lists as sequences.
Syntax
Definition
Result
(seq &lsquo;(1 2 3 4))
If collection is not empty, return seq object else nil
(1 2 3 4)
(first [1 2 3 4])
returns the first element
1
(rest {:a 1 :b 2 :c 3 :d 4})"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        m365 blog
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>


    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <header>
        <h1 class="f1">
          Clojure Sequences
        </h1>
      </header>
      <div class="nested-copy-line-height lh-copy f4 nested-links mid-gray">
        <p>Sequences include data structure lists, vectors and lazy sequences. Functions that can be used with sequences can be found using the clojure cheatsheet. <a href="http://clojure.org/cheatsheet">http://clojure.org/cheatsheet</a> Below are some examples using vectors and lists as sequences.</p>
<p> Syntax</p>
<p> Definition</p>
<p> Result</p>
<p> (seq &lsquo;(1 2 3 4))</p>
<p> If collection is not empty, return seq object else nil</p>
<p> (1 2 3 4)</p>
<p> (first [1 2 3 4])</p>
<p> returns the first element</p>
<p> 1</p>
<p> (rest {:a 1 :b 2 :c 3 :d 4})</p>
<p> returns a sequence of the rest of elements after first element</p>
<p> ([:b 2][:c 3][:d 4])</p>
<p> (cons 1 &lsquo;( 2 3 4))</p>
<p> returns a new sequence: first is 1, rest is coll</p>
<p> (1 2 3 4)</p>
<p><strong>Lazy Sequences</strong> Lazy Sequences are integral part of Clojure. They are not actually data structures but are objects that contain function which return next item in the sequence. Lazy sequences allow for gen­er­ated log­i­cal sequence which does­n’t have to exist in mem­o­ry. It makes it pos­si­ble to have infi­nite sequences which can be cached and used whenever needed. Examples of functions used with lazy sequences are:</p>
<p>Syntax</p>
<p>Definition</p>
<p>Result</p>
<p> (range)</p>
<p> generates lazy sequence of numbers infinitely</p>
<p>(0 1 2 3 4 5&hellip;n)</p>
<p> (range 3)</p>
<p> returns first three numbers from the sequence.</p>
<p> (0 1 2)</p>
<p> (range 1 7 2)</p>
<p> returns numbers with increment of 2 starting from 1 and ending 7</p>
<p> (1 3 5)</p>
<p> (range 1 4)</p>
<p> returns numbers starting at 1 and ending at 4</p>
<p> (1 2 3)</p>
<p>(take 4  (range))</p>
<p> take first 4 numbers</p>
<p> (0 1 2 3)</p>
<p>(drop 4 (range))</p>
<p>similar to Take except means discarding the first 4 items</p>
<p>(4 5 6 7&hellip;n)</p>
<p>(iterate inc 5)</p>
<p> iterate returns a lazy sequence starting at 5 using the inc function</p>
<p>(5 6 7 8 9 10 11 &hellip;.n)</p>
<p>(take 4 (iterate (partial * 2) 5))</p>
<p>starting at 5 using the  multiply operation 2.</p>
<p>(5 10 20 40)</p>
<p> (map #(* % %) [0 1 2 3])</p>
<p> map iterates through each element in the vector and calculate the square of the number</p>
<p> (0 1 4 9 )</p>
<p> (filter even? (range))</p>
<p>filter takes some sequence and predicate and return sequence of elements where predicate is true. The example returns all even numbers</p>
<p> (0 2 4 6 8&hellip;.n)</p>
<p> (re-seq #&quot;[aeiou]&quot; &ldquo;clojure&rdquo;)</p>
<p> returns sequence of successive matches of pattern in string</p>
<p> (&ldquo;o&rdquo; &ldquo;u&rdquo; &ldquo;e&rdquo;)</p>
<p>An example of the application of the iterate function is to generate Fibonacci numbers. Fibonacci returns where a number is found by adding up the two numbers before it. Starting with 0 and 1, the sequence goes 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, and so forth, i.e.  Xn = Xn-1 + Xn-2. Let&rsquo;s write it in clojure</p>
<ol>
<li>Start with vector [0 1] which is the starting Fibonacci sequence</li>
<li>Generate a sequence of elements from this vector added to each other using the iterate function. Iterate takes the starting vector [1 0] and applies a function <code>(iterate ([0 1])</code></li>
<li> Define the function with single argument to which [0 1] will be passed. Destructure the argument into symbols a and b. a contains 0 while b  contains 1. <code>(iterate (fn [[a b]] [0 1]))</code></li>
<li>Inside the function, return a vector which is the sequence of next element. first element of the vector is b which is one and the second element of vector is a +b which is 1 also. <code>(iterate (fn  [[a b]] [b (+ a b)]) [0 1]))</code> Running above code in REPL produces the following sequence [0 1] [1 1] [1 2][2 3][3 5][5 8]&hellip;&hellip;[n n] <a href="https://reshmeeauckloo.files.wordpress.com/2015/12/iterate.jpg"><img src="https://reshmeeauckloo.files.wordpress.com/2015/12/iterate.jpg?w=300" alt="Iterate"></a></li>
<li>The first element of the vector returned needs to be returned</li>
<li>The map function can be used to iterate over each vector and using function first , the first element of the vector can be extracted <code>(map first (iterate (fn  [[a b]] [b (+ a b)]) [0 1])))</code> <a href="https://reshmeeauckloo.files.wordpress.com/2015/12/mapfirst.jpg"><img src="https://reshmeeauckloo.files.wordpress.com/2015/12/mapfirst.jpg?w=300" alt="mapfirst"></a></li>
<li>Create a function to generate the Fibonacci which can be invoked <code>(def fibs (map first (iterate (fn [[a b]] [b (+ a b)]) [0 1])))</code> <code>;;return first five Fibonacci numbers (take 5 fibs) ;;drop first five Fibonacci numbers and return the rest up to infinite (drop 5 fibs)</code> <a href="https://reshmeeauckloo.files.wordpress.com/2015/12/fibonacci.jpg"><img src="https://reshmeeauckloo.files.wordpress.com/2015/12/fibonacci.jpg?w=300" alt="Fibonacci"></a> <code>(map inc (take 5 fibs))</code> <a href="https://reshmeeauckloo.files.wordpress.com/2015/12/mapinc.jpg"><img src="https://reshmeeauckloo.files.wordpress.com/2015/12/mapinc.jpg?w=300" alt="mapinc"></a> It returns the first 5 Fibonacci numbers added to 1</li>
</ol>
<p><strong>Other Functions  on Sequences</strong></p>
<p>Syntax</p>
<p>Definition</p>
<p>Result</p>
<p> (reduce + (range 4))</p>
<p> reduce iterately invoke the function + with every element of the sequence</p>
<p> 6</p>
<p>  (reduce + 10 (range 4))</p>
<p> reduce retains the result of the previous indication and uses it as first argument in subsequent function. Sum of the sequence + 10</p>
<p> 16</p>
<p> (into #{} &ldquo;hello&rdquo;)</p>
<p>  Into functions injects element of the sequence into a concrete data structure</p>
<p> #{\e \h \l \o}</p>
<p> (into {} [[:x 1] [:y 2]])</p>
<p>  pouring sequence of key value pairs into a map</p>
<p> {:x 1, :y 2}</p>
<p>( some {2 :b 3 :c} [1 nil 2 3])</p>
<p>  some takes a predicate function and returns the first element of the sequence for which the predicate function returns logical true. Takes advantage of map being a function. Each element in the vector 1, nil, 2 and 3 is passed as argument to the map. True is returned when 2 is reached. 2 is a key in the map which returns the value b.</p>
<p> b</p>
<p> (interleave [:a :b :c :d :e] [1 2 3 4 5])</p>
<p> returns a seq of the first item in each coll, then the second etc.</p>
<p>  (:a 1 :b 2 :c 3 :d 4 :e 5)</p>
<p> (partition 3 [1 2 3 4 5 6 7 8 9])</p>
<p> returns sequence of lists of 3 items each.</p>
<p>  ((1 2 3) (4 5 6) (7 8 9))</p>
<p> (map vector [:a :b :c :d :e] [1 2 3 4 5])</p>
<p> returns sequence of vectors associating key from first coll with value from second coll</p>
<p>  ([:a 1] [:b 2] [:c 3] [:d 4] [:e 5]</p>
<p> (apply str (interpose \,&ldquo;asdf&rdquo;))</p>
<p> a series of functions are applied. Interpose add the &ldquo;,&rdquo; to each letter in the string and returns a list (\a \, \s \,\ d \,\ f \) str joins the list of strings into one string.</p>
<p> &ldquo;a, s, d, f</p>

      </div>
    </article>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://famous-cajeta-4dad83.netlify.app/" >
    &copy;  m365 blog 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
