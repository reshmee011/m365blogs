<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Clojure loop: doseq,dotimes, while, loop, recur - m365 blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://famous-cajeta-4dad83.netlify.app/clojure-loop-doseqdotimes-while-loop-recur/index.xml title="m365 blog"><meta itemprop=name content="Clojure loop: doseq,dotimes, while, loop, recur"><meta itemprop=description content="In Clojure loop can be performed using doseq, dotimes, while,loop, loop/recur and defn/recur functions. doseq doseq function iterates over a sequence performing something against each element. It is similar to foreach in C#. doseq forces evaluation for a lazy sequence (doseq [n (range 3)] ;;binding each value from the seq to n (println n)) Result : (0 1 2) dotimes dotimes function evaluates same expression n times similar to for loop in C#."><meta itemprop=datePublished content="2015-12-17T19:59:30+00:00"><meta itemprop=dateModified content="2015-12-17T19:59:30+00:00"><meta itemprop=wordCount content="439"><meta itemprop=keywords content="Clojure,clojure loop,Uncategorized,"><meta property="og:title" content="Clojure loop: doseq,dotimes, while, loop, recur"><meta property="og:description" content="In Clojure loop can be performed using doseq, dotimes, while,loop, loop/recur and defn/recur functions. doseq doseq function iterates over a sequence performing something against each element. It is similar to foreach in C#. doseq forces evaluation for a lazy sequence (doseq [n (range 3)] ;;binding each value from the seq to n (println n)) Result : (0 1 2) dotimes dotimes function evaluates same expression n times similar to for loop in C#."><meta property="og:type" content="article"><meta property="og:url" content="https://famous-cajeta-4dad83.netlify.app/clojure-loop-doseqdotimes-while-loop-recur/"><meta property="article:section" content><meta property="article:published_time" content="2015-12-17T19:59:30+00:00"><meta property="article:modified_time" content="2015-12-17T19:59:30+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Clojure loop: doseq,dotimes, while, loop, recur"><meta name=twitter:description content="In Clojure loop can be performed using doseq, dotimes, while,loop, loop/recur and defn/recur functions. doseq doseq function iterates over a sequence performing something against each element. It is similar to foreach in C#. doseq forces evaluation for a lazy sequence (doseq [n (range 3)] ;;binding each value from the seq to n (println n)) Result : (0 1 2) dotimes dotimes function evaluates same expression n times similar to for loop in C#."><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://famous-cajeta-4dad83.netlify.app/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://famous-cajeta-4dad83.netlify.app/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://famous-cajeta-4dad83.netlify.app/css/dark.css><script src=https://famous-cajeta-4dad83.netlify.app/js/main.js></script></head><body><div class="container wrapper"><div class=header><h1 class=site-title><a href=https://famous-cajeta-4dad83.netlify.app/>m365 blog</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>17</span>
<span class=rest>Dec 2015</span></div></div><div class=matter><h1 class=title>Clojure loop: doseq,dotimes, while, loop, recur</h1></div></div><div class=markdown><p>In Clojure loop can be performed using doseq, dotimes, while,loop, loop/recur and defn/recur functions. <strong>doseq</strong> <strong>doseq</strong> function iterates over a sequence performing something against each element. It is similar to foreach in C#. <strong>doseq</strong> forces evaluation for a lazy sequence <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/doseq.jpg alt=doseq> <code>(doseq [n (range 3)] ;;binding each value from the seq to n (println n))</code> Result : (0 1 2) <strong>dotimes</strong> <strong>dotimes</strong> function evaluates same expression n times similar to for loop in C#. <strong>dotimes</strong> takes a name and a value vector and performs the expression inside of it number of times based on value passed. <code>(dotimes [i 3] (println i))</code> <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/dotimes.jpg alt=dotimes> <strong>while</strong> <strong>while</strong> function in clojure is similar to while in C#. <strong>while</strong> continues evaluating the body as long as the condition is true <code>(def a (atom 10)) (while (&lt; 0 @a)  (do (println @a) (swap! a dec)))</code> <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/while.jpg alt=while.JPG> In the above example, an atom with initial value of 10 is created and assigned to symbol a. Atoms provide a way to manage shared, synchronous, independent state. They are a reference type like refs, i.e, points to a value. The swap function updates the value of the atom. The dec function substracts 1 from the atom value. The while is executed until the atom a value is no longer less than 0. <strong>loop/recur</strong> <strong>loop/recur</strong> takes a binding vector and a condition is defined and recur is used to re-execute loop with new bindings. <code>(loop [i 0]</code> (if(&lt; i 10) (recur (inc i))  i)) In the example above loop initialises  i down to 0 and iteratively increments by 1 with the help of recur until i is 10. <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/loop.jpg alt=loop> <strong>defn/recur</strong> <strong>defn/recur</strong> can act as loop expressions in the sense that a recur inside the function is meaningful and results in the functions being called again with new bindings as specified by recur. <code>(defn increase [i] (if(&lt; i 10) (recur (inc i)) i)) (increase 1)</code> <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/defnrecur.jpg alt=defnRecur> In above example, the loop from previous example is defined into a named function increase that takes a single argument. if a number less than 10 is passed, increase will loop some number of times and return i until 10 is reached. An example how the defn/recur  is useful is the factorial function found from <a href=http://stackoverflow.com/questions/1662336/clojure-simple-factorial-causes-stack-overflow>http://stackoverflow.com/questions/1662336/clojure-simple-factorial-causes-stack-overflow</a> <code>(defn fact[x] (if (&lt;= x 1) 1 (* x (fact (- x 1)) )))</code> (fact 1000) ;; throws arithmeticException integer overflow <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/arithmeticoverflow.jpg alt=ArithmeticOverflow.JPG> The factorial function breaks with integer overflow with 1000. The combination of defn/recur can be used to prevent the error Clojure uses the tail-call optimisation so that the overflow does not occur <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/def_recur.jpg alt=def_recur.JPG> <code>(defn factorial ([x] (factorial 1 x)) ([accum x] (if (&lt;= x 1) accum (recur(*' accum x)(- x 1))))) (factorial 1)</code></p></div><div class=tags></div></div></div><div class="footer wrapper"><nav class=nav><div>2023 <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div></nav></div></body></html>