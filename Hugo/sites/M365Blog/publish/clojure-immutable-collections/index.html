<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Clojure Immutable Collections | Reshmee blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Clojure data is immutable. Values of simple data types are immutable , e.g. true, 4, 4.05. With immutability values never change, instead new values are generated when new states are needed. It means all states of the collection can be referred throughout the life cycle of the application. Advantages of immutability can be read from blog http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm Clojure provides several immutable collections listed below Lists Below are the syntax associated with lists"><meta name=generator content="Hugo 0.111.3"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><link href=/clojure-immutable-collections/index.xml rel=alternate type=application/rss+xml title="Reshmee blog"><link href=/clojure-immutable-collections/index.xml rel=feed type=application/rss+xml title="Reshmee blog"><meta property="og:title" content="Clojure Immutable Collections"><meta property="og:description" content="Clojure data is immutable. Values of simple data types are immutable , e.g. true, 4, 4.05. With immutability values never change, instead new values are generated when new states are needed. It means all states of the collection can be referred throughout the life cycle of the application. Advantages of immutability can be read from blog http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm Clojure provides several immutable collections listed below Lists Below are the syntax associated with lists"><meta property="og:type" content="article"><meta property="og:url" content="https://reshmee.netlify.app/clojure-immutable-collections/"><meta property="article:section" content><meta property="article:published_time" content="2015-12-06T16:02:01+00:00"><meta property="article:modified_time" content="2015-12-06T16:02:01+00:00"><meta itemprop=name content="Clojure Immutable Collections"><meta itemprop=description content="Clojure data is immutable. Values of simple data types are immutable , e.g. true, 4, 4.05. With immutability values never change, instead new values are generated when new states are needed. It means all states of the collection can be referred throughout the life cycle of the application. Advantages of immutability can be read from blog http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm Clojure provides several immutable collections listed below Lists Below are the syntax associated with lists"><meta itemprop=datePublished content="2015-12-06T16:02:01+00:00"><meta itemprop=dateModified content="2015-12-06T16:02:01+00:00"><meta itemprop=wordCount content="567"><meta itemprop=keywords content="Clojure,Data Types Immutability,Uncategorized,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Clojure Immutable Collections"><meta name=twitter:description content="Clojure data is immutable. Values of simple data types are immutable , e.g. true, 4, 4.05. With immutability values never change, instead new values are generated when new states are needed. It means all states of the collection can be referred throughout the life cycle of the application. Advantages of immutability can be read from blog http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm Clojure provides several immutable collections listed below Lists Below are the syntax associated with lists"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Reshmee blog</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><div class="flex-l mt2 mw8 center"><article class="center cf pv5 ph3 ph4-ns mw7"><header><h1 class=f1>Clojure Immutable Collections</h1></header><div class="nested-copy-line-height lh-copy f4 nested-links mid-gray"><p>Clojure data is immutable. Values of simple data types are immutable , e.g. true, 4, 4.05. With immutability values never change, instead new values are generated  when new states  are needed. It means all states of the collection can be referred throughout the life cycle of the application. Advantages of immutability can be read from blog <a href=http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm>http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm</a> Clojure provides several immutable collections listed below <strong>Lists</strong> Below are the syntax associated with lists</p><p>Syntax</p><p>Definition</p><p>Result</p><p> ()</p><p> empty list</p><p> (1 2 3)</p><p>  1 is interpreted as a function and fails</p><p> &lsquo;(1 2 3) or (list 1 2 3)</p><p>The quote sign means don&rsquo;t evaluate the list and is a macro for denoting list.</p><p> (1 2 3)</p><p>(conj &lsquo;(1 2 3) 1)</p><p>The conj add value 1 at beginning of list</p><p> (1 1 2 3 )</p><p><img src=https://reshmeeauckloo.files.wordpress.com/2015/12/list_data1.jpg alt=List_Data> lst returns (1 2 3) in the screenshot because  of immutability. <strong>Vectors</strong> Vector is similar to array object in other languages like C# and JavaScript</p><p>Syntax</p><p>Definition</p><p>Result</p><p> []</p><p> empty vector</p><p> []</p><p> [1 2 3] (vector 1 2 3) (vec &lsquo;(1 2 3))</p><p>vector can be defined using the [] symbols vector is a function to define a vector. vec is a function to convert list into vector</p><p> [1 2 3]</p><p>(nth [1 2 3] 0]</p><p> returns element at position 0</p><p> 1</p><p>(conj [1 2 3]  1)</p><p>add 3 to vector</p><p> [1 2 3 1]</p><p><img src=https://reshmeeauckloo.files.wordpress.com/2015/12/vector_data.jpg alt=Vector_data> <strong>Map</strong> Maps is similar to dictionary object in C#. The values stored are unordered.</p><p>Syntax</p><p>Definition</p><p>Result</p><p> {}</p><p> empty map</p><p>  {:a 1 :b 2}</p><p>Map collection containing a is a pointer to 1 b is a pointer to 2</p><p>   {:a 1 , :b 2}</p><p>(assoc  {:a 1 :b 2} :c 3)</p><p> associate key c with the map</p><p>  {:c 3 , :a 1, :b 2 }</p><p>(dissoc {:a 1 :b 2} :a)</p><p>dissociates key a from map</p><p> {:b 2}</p><p>(conj {:a 1 :b 2} [:a 1])</p><p>add vector key a to map</p><p>   {:c 1 , :a 1, :b 2 }</p><p><img src=https://reshmeeauckloo.files.wordpress.com/2015/12/map_data.jpg alt=Map_Data> Nested access to data in maps is possible using helper functions  via path specified by keys</p><p>Syntax</p><p>Definition</p><p>Result</p><p> (def jsmith {:name &ldquo;John Smith&rdquo; :age 50, :address {:postcode &ldquo;sw 12ap&rdquo; :Street &ldquo;Royal Road&rdquo;}})</p><p> defines a map object called jsmith</p><p> (get jsmith :name)</p><p> get function returns the key value</p><p> &ldquo;John Smith&rdquo;</p><p> (get-in jsmith [:address :postcode])</p><p> get-in function returns the nested key</p><p> &ldquo;sw 12ap&rdquo;</p><p>(assoc jsmith :age 40)</p><p>assoc functions associates value to key</p><p> (def jsmith {:name &ldquo;John Smith&rdquo; :age 40, :address {:postcode &ldquo;sw 12ap&rdquo; :Street &ldquo;Royal Road&rdquo;}})</p><p>(assoc-in jsmith [:address :postcode] &ldquo;n1 0lk&rdquo;)</p><p>assoc-in  associate value to nested key</p><p> (def jsmith {:name &ldquo;John Smith&rdquo; :age 50, :address {:postcode &ldquo;n1 0lk&rdquo; :Street &ldquo;Royal Road&rdquo;}})</p><p> (update-in jsmith [:age] inc)</p><p> update-in functions is used to apply a function to the key value inc  function increments  value by 1</p><p> (def jsmith {:name &ldquo;John Smith&rdquo; :age 51, :address {:postcode &ldquo;sw 12ap&rdquo; :Street &ldquo;Royal Road&rdquo;}})</p><p><img src=https://reshmeeauckloo.files.wordpress.com/2015/12/nestedacessmap.jpg alt=NestedAcessMap> <strong>Sets</strong> Set contains unordered list of distinct values</p><p>Syntax</p><p>Definition</p><p>Result</p><p> #{}</p><p> empty set</p><p> #{:a :b}</p><p> set with keys a and b</p><p>  (#{:a :b} :a)</p><p> returns key a from set</p><p>  :a</p><p> (conj #{:b :c} :a)</p><p>conj function adds key to set</p><p> #{c: :b :a}</p><p>(contains? #{:a :e} :e)</p><p>contains function return a Boolean</p><p>true</p><p> (contains? #{:a :e} :h)</p><p> contains function return a Boolean</p><p> false</p><p><img src=https://reshmeeauckloo.files.wordpress.com/2015/12/set_data1.jpg alt=Set_Data> The screenshot above has been produced using lein repl as for some reasons LightTable from my laptop could not work out # symbol in front of {}. <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/error.jpg alt=error#></p></div></article></div></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://reshmee.netlify.app/>&copy; Reshmee blog 2023</a><div><div class=ananke-socials></div></div></div></footer></body></html>