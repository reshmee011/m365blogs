<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Clojure Immutable Collections - m365 blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://famous-cajeta-4dad83.netlify.app/clojure-immutable-collections/index.xml title="m365 blog"><meta itemprop=name content="Clojure Immutable Collections"><meta itemprop=description content="Clojure data is immutable. Values of simple data types are immutable , e.g. true, 4, 4.05. With immutability values never change, instead new values are generated when new states are needed. It means all states of the collection can be referred throughout the life cycle of the application. Advantages of immutability can be read from blog http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm Clojure provides several immutable collections listed below Lists Below are the syntax associated with lists"><meta itemprop=datePublished content="2015-12-06T16:02:01+00:00"><meta itemprop=dateModified content="2015-12-06T16:02:01+00:00"><meta itemprop=wordCount content="567"><meta itemprop=keywords content="Clojure,Data Types Immutability,Uncategorized,"><meta property="og:title" content="Clojure Immutable Collections"><meta property="og:description" content="Clojure data is immutable. Values of simple data types are immutable , e.g. true, 4, 4.05. With immutability values never change, instead new values are generated when new states are needed. It means all states of the collection can be referred throughout the life cycle of the application. Advantages of immutability can be read from blog http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm Clojure provides several immutable collections listed below Lists Below are the syntax associated with lists"><meta property="og:type" content="article"><meta property="og:url" content="https://famous-cajeta-4dad83.netlify.app/clojure-immutable-collections/"><meta property="article:section" content><meta property="article:published_time" content="2015-12-06T16:02:01+00:00"><meta property="article:modified_time" content="2015-12-06T16:02:01+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Clojure Immutable Collections"><meta name=twitter:description content="Clojure data is immutable. Values of simple data types are immutable , e.g. true, 4, 4.05. With immutability values never change, instead new values are generated when new states are needed. It means all states of the collection can be referred throughout the life cycle of the application. Advantages of immutability can be read from blog http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm Clojure provides several immutable collections listed below Lists Below are the syntax associated with lists"><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://famous-cajeta-4dad83.netlify.app/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://famous-cajeta-4dad83.netlify.app/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://famous-cajeta-4dad83.netlify.app/css/dark.css><script src=https://famous-cajeta-4dad83.netlify.app/js/main.js></script></head><body><div class="container wrapper"><div class=header><h1 class=site-title><a href=https://famous-cajeta-4dad83.netlify.app/>m365 blog</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>06</span>
<span class=rest>Dec 2015</span></div></div><div class=matter><h1 class=title>Clojure Immutable Collections</h1></div></div><div class=markdown><p>Clojure data is immutable. Values of simple data types are immutable , e.g. true, 4, 4.05. With immutability values never change, instead new values are generated  when new states  are needed. It means all states of the collection can be referred throughout the life cycle of the application. Advantages of immutability can be read from blog <a href=http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm>http://www.developer.com/lang/other/article.php/3874551/Clojure-Immutability-at-the-Language-Level.htm</a> Clojure provides several immutable collections listed below <strong>Lists</strong> Below are the syntax associated with lists</p><p>Syntax</p><p>Definition</p><p>Result</p><p> ()</p><p> empty list</p><p> (1 2 3)</p><p>  1 is interpreted as a function and fails</p><p> &lsquo;(1 2 3) or (list 1 2 3)</p><p>The quote sign means don&rsquo;t evaluate the list and is a macro for denoting list.</p><p> (1 2 3)</p><p>(conj &lsquo;(1 2 3) 1)</p><p>The conj add value 1 at beginning of list</p><p> (1 1 2 3 )</p><p><img src=https://reshmeeauckloo.files.wordpress.com/2015/12/list_data1.jpg alt=List_Data> lst returns (1 2 3) in the screenshot because  of immutability. <strong>Vectors</strong> Vector is similar to array object in other languages like C# and JavaScript</p><p>Syntax</p><p>Definition</p><p>Result</p><p> []</p><p> empty vector</p><p> []</p><p> [1 2 3] (vector 1 2 3) (vec &lsquo;(1 2 3))</p><p>vector can be defined using the [] symbols vector is a function to define a vector. vec is a function to convert list into vector</p><p> [1 2 3]</p><p>(nth [1 2 3] 0]</p><p> returns element at position 0</p><p> 1</p><p>(conj [1 2 3]  1)</p><p>add 3 to vector</p><p> [1 2 3 1]</p><p><img src=https://reshmeeauckloo.files.wordpress.com/2015/12/vector_data.jpg alt=Vector_data> <strong>Map</strong> Maps is similar to dictionary object in C#. The values stored are unordered.</p><p>Syntax</p><p>Definition</p><p>Result</p><p> {}</p><p> empty map</p><p>  {:a 1 :b 2}</p><p>Map collection containing a is a pointer to 1 b is a pointer to 2</p><p>   {:a 1 , :b 2}</p><p>(assoc  {:a 1 :b 2} :c 3)</p><p> associate key c with the map</p><p>  {:c 3 , :a 1, :b 2 }</p><p>(dissoc {:a 1 :b 2} :a)</p><p>dissociates key a from map</p><p> {:b 2}</p><p>(conj {:a 1 :b 2} [:a 1])</p><p>add vector key a to map</p><p>   {:c 1 , :a 1, :b 2 }</p><p><img src=https://reshmeeauckloo.files.wordpress.com/2015/12/map_data.jpg alt=Map_Data> Nested access to data in maps is possible using helper functions  via path specified by keys</p><p>Syntax</p><p>Definition</p><p>Result</p><p> (def jsmith {:name &ldquo;John Smith&rdquo; :age 50, :address {:postcode &ldquo;sw 12ap&rdquo; :Street &ldquo;Royal Road&rdquo;}})</p><p> defines a map object called jsmith</p><p> (get jsmith :name)</p><p> get function returns the key value</p><p> &ldquo;John Smith&rdquo;</p><p> (get-in jsmith [:address :postcode])</p><p> get-in function returns the nested key</p><p> &ldquo;sw 12ap&rdquo;</p><p>(assoc jsmith :age 40)</p><p>assoc functions associates value to key</p><p> (def jsmith {:name &ldquo;John Smith&rdquo; :age 40, :address {:postcode &ldquo;sw 12ap&rdquo; :Street &ldquo;Royal Road&rdquo;}})</p><p>(assoc-in jsmith [:address :postcode] &ldquo;n1 0lk&rdquo;)</p><p>assoc-in  associate value to nested key</p><p> (def jsmith {:name &ldquo;John Smith&rdquo; :age 50, :address {:postcode &ldquo;n1 0lk&rdquo; :Street &ldquo;Royal Road&rdquo;}})</p><p> (update-in jsmith [:age] inc)</p><p> update-in functions is used to apply a function to the key value inc  function increments  value by 1</p><p> (def jsmith {:name &ldquo;John Smith&rdquo; :age 51, :address {:postcode &ldquo;sw 12ap&rdquo; :Street &ldquo;Royal Road&rdquo;}})</p><p><img src=https://reshmeeauckloo.files.wordpress.com/2015/12/nestedacessmap.jpg alt=NestedAcessMap> <strong>Sets</strong> Set contains unordered list of distinct values</p><p>Syntax</p><p>Definition</p><p>Result</p><p> #{}</p><p> empty set</p><p> #{:a :b}</p><p> set with keys a and b</p><p>  (#{:a :b} :a)</p><p> returns key a from set</p><p>  :a</p><p> (conj #{:b :c} :a)</p><p>conj function adds key to set</p><p> #{c: :b :a}</p><p>(contains? #{:a :e} :e)</p><p>contains function return a Boolean</p><p>true</p><p> (contains? #{:a :e} :h)</p><p> contains function return a Boolean</p><p> false</p><p><img src=https://reshmeeauckloo.files.wordpress.com/2015/12/set_data1.jpg alt=Set_Data> The screenshot above has been produced using lein repl as for some reasons LightTable from my laptop could not work out # symbol in front of {}. <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/error.jpg alt=error#></p></div><div class=tags></div></div></div><div class="footer wrapper"><nav class=nav><div>2023 <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div></nav></div></body></html>