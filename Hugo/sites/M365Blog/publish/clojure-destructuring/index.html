<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Clojure Destructuring - m365 blog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate type=application/rss+xml href=https://famous-cajeta-4dad83.netlify.app/clojure-destructuring/index.xml title="m365 blog"><meta itemprop=name content="Clojure Destructuring"><meta itemprop=description content="Destructuring allows to extract values from datastructures and bind them to symbols without explicitly looping/traversing the datastructure. It allows concise and simple coding.
Sequential Destructuring Provides vector of symbols to bind by position. Syntax: [symbol another-symbol] [&ldquo;value&rdquo; &ldquo;another-value&rdquo;] (def listNumbers[7 8 9 10 11]) ;;Bind a, b, c to first 3 values in stuff (let [[a b c] listNumbers] (list (+ a b) (+ b c))) Result: (15,17) It binds to nil if there&rsquo;s no data, i."><meta itemprop=datePublished content="2015-12-09T09:55:41+00:00"><meta itemprop=dateModified content="2015-12-09T09:55:41+00:00"><meta itemprop=wordCount content="354"><meta itemprop=keywords content="Clojure,Clojure Destructuring,Functional Programming,"><meta property="og:title" content="Clojure Destructuring"><meta property="og:description" content="Destructuring allows to extract values from datastructures and bind them to symbols without explicitly looping/traversing the datastructure. It allows concise and simple coding.
Sequential Destructuring Provides vector of symbols to bind by position. Syntax: [symbol another-symbol] [&ldquo;value&rdquo; &ldquo;another-value&rdquo;] (def listNumbers[7 8 9 10 11]) ;;Bind a, b, c to first 3 values in stuff (let [[a b c] listNumbers] (list (+ a b) (+ b c))) Result: (15,17) It binds to nil if there&rsquo;s no data, i."><meta property="og:type" content="article"><meta property="og:url" content="https://famous-cajeta-4dad83.netlify.app/clojure-destructuring/"><meta property="article:section" content><meta property="article:published_time" content="2015-12-09T09:55:41+00:00"><meta property="article:modified_time" content="2015-12-09T09:55:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Clojure Destructuring"><meta name=twitter:description content="Destructuring allows to extract values from datastructures and bind them to symbols without explicitly looping/traversing the datastructure. It allows concise and simple coding.
Sequential Destructuring Provides vector of symbols to bind by position. Syntax: [symbol another-symbol] [&ldquo;value&rdquo; &ldquo;another-value&rdquo;] (def listNumbers[7 8 9 10 11]) ;;Bind a, b, c to first 3 values in stuff (let [[a b c] listNumbers] (list (+ a b) (+ b c))) Result: (15,17) It binds to nil if there&rsquo;s no data, i."><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://famous-cajeta-4dad83.netlify.app/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://famous-cajeta-4dad83.netlify.app/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://famous-cajeta-4dad83.netlify.app/css/dark.css><script src=https://famous-cajeta-4dad83.netlify.app/js/main.js></script></head><body><div class="container wrapper"><div class=header><h1 class=site-title><a href=https://famous-cajeta-4dad83.netlify.app/>m365 blog</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>09</span>
<span class=rest>Dec 2015</span></div></div><div class=matter><h1 class=title>Clojure Destructuring</h1></div></div><div class=markdown><p>Destructuring allows to extract values from datastructures and bind them to symbols without explicitly looping/traversing the datastructure. It allows concise and simple coding.</p><h3 id=sequential-destructuring><strong>Sequential Destructuring</strong></h3><p>Provides vector of symbols to bind by position. <strong>Syntax:</strong> [symbol another-symbol] [&ldquo;value&rdquo; &ldquo;another-value&rdquo;] <code>(def listNumbers[7 8 9 10 11]) ;;Bind a, b, c to first 3 values in stuff (let [[a b c] listNumbers] (list (+ a b) (+ b c)))</code> Result: (15,17) <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/sequentialdestructuring.jpg alt=SequentialDestructuring> It binds to nil if there&rsquo;s no data, i.e. there are not enough items in the vector to bind to. <code>(let [[a b c d e f] listNumbers] (list d e f))</code> Result : (10 11 nil) <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/nil_destructuring.jpg alt=Nil_Destructuring> In the above example there is no data at 6th position in ListNumbers collection to bind to f explaining the nil being returned. <strong>&</strong> symbol can get &ldquo;everything else&rdquo; with value being a sequence <code>(def listNumbers[7 8 9 10 11]) (let [[a & others] listNumbers] (list others))</code> Result : (8 9 10 11 <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/others.jpg alt=&amp;amp;_Others> _  symbol is used for values that can be discarded First element is discarded in the example below <code>(def listNumbers[7 8 9 10 11])</code> (let [[_ & others] listNumbers] (list others))) ) Result : (8 9 10 11) <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/discard.jpg alt="_ Discard"></p><h3 id=associative-destructuring><strong>Associative Destructuring</strong></h3><p>Provides map of symbols to bind by key. <strong>Syntax: {symbol :key, another-symbol :another-key} {:key &ldquo;value&rdquo; :another-key &ldquo;another-value&rdquo;}</strong> <code>(def m {:a 7 :b 4}) (let [{a :a, b :b} m] [a b])</code> Result : [7 4] <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/associativedestructuring.jpg alt=AssociativeDestructuring> <strong>keys</strong>  are inferred from vector of symbols to bind <code>(def m {:a 7 :b 4}) (let [{:keys [a b]} m] [a b])</code> Result : [7 4] <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/keys_map.jpg alt=Keys_Map> If a key is not found in the map, the symbol is bound to <code>nil</code>. <code>(let [{:keys [a b c]} m] [a b c])</code> Result: [7 4 nil] <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/map_nil.jpg alt=Map_Nil> <strong>:or</strong> provides default values for missing keys with a map of values <code>(def m {:a 7 :b 4}) (let [{:keys [a b c] :or {c 3}} m] [a b c])</code> Result: [7 4 3] <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/or_map.jpg alt=Or_Map> **Named Arguments ** Vector of keys can be bound to <strong>&</strong> to emulate optional named arguments. <code>(defn people [planet & {:keys [adults children]}] (+ adults children))</code> (people &ldquo;Earth&rdquo; :adults 1 :children 5) Result:6 <img src=https://reshmeeauckloo.files.wordpress.com/2015/12/namedarguments.jpg alt=NamedArguments></p></div><div class=tags></div></div></div><div class="footer wrapper"><nav class=nav><div>2023 <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div></nav></div></body></html>